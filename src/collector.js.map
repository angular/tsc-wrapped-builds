{"version":3,"file":"collector.js","sourceRoot":"","sources":["../../../../../tools/@angular/tsc-wrapped/src/collector.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport {Evaluator, errorSymbol, isPrimitive} from './evaluator';\nimport {ClassMetadata, ConstructorMetadata, FunctionMetadata, MemberMetadata, MetadataError, MetadataMap, MetadataObject, MetadataSymbolicExpression, MetadataSymbolicReferenceExpression, MetadataSymbolicSelectExpression, MetadataValue, MethodMetadata, ModuleExportMetadata, ModuleMetadata, VERSION, isMetadataError, isMetadataSymbolicReferenceExpression, isMetadataSymbolicSelectExpression} from './schema';\nimport {Symbols} from './symbols';\n\n\n\n/**\n * Collect decorator metadata from a TypeScript module.\n */\nexport class MetadataCollector {\n  constructor() {}\n\n  /**\n   * Returns a JSON.stringify friendly form describing the decorators of the exported classes from\n   * the source file that is expected to correspond to a module.\n   */\n  public getMetadata(sourceFile: ts.SourceFile): ModuleMetadata {\n    const locals = new Symbols(sourceFile);\n    const evaluator = new Evaluator(locals);\n    let metadata: {[name: string]: MetadataValue | ClassMetadata | FunctionMetadata}|undefined;\n    let exports: ModuleExportMetadata[];\n\n    function objFromDecorator(decoratorNode: ts.Decorator): MetadataSymbolicExpression {\n      return <MetadataSymbolicExpression>evaluator.evaluateNode(decoratorNode.expression);\n    }\n\n    function errorSym(\n        message: string, node?: ts.Node, context?: {[name: string]: string}): MetadataError {\n      return errorSymbol(message, node, context, sourceFile);\n    }\n\n    function maybeGetSimpleFunction(\n        functionDeclaration: ts.FunctionDeclaration |\n        ts.MethodDeclaration): {func: FunctionMetadata, name: string}|undefined {\n      if (functionDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n        const nameNode = <ts.Identifier>functionDeclaration.name;\n        const functionName = nameNode.text;\n        const functionBody = functionDeclaration.body;\n        if (functionBody && functionBody.statements.length == 1) {\n          const statement = functionBody.statements[0];\n          if (statement.kind === ts.SyntaxKind.ReturnStatement) {\n            const returnStatement = <ts.ReturnStatement>statement;\n            if (returnStatement.expression) {\n              const func: FunctionMetadata = {\n                __symbolic: 'function',\n                parameters: namesOf(functionDeclaration.parameters),\n                value: evaluator.evaluateNode(returnStatement.expression)\n              };\n              if (functionDeclaration.parameters.some(p => p.initializer != null)) {\n                const defaults: MetadataValue[] = [];\n                func.defaults = functionDeclaration.parameters.map(\n                    p => p.initializer && evaluator.evaluateNode(p.initializer));\n              }\n              return { func, name: functionName }\n            }\n          }\n        }\n      }\n    }\n\n    function classMetadataOf(classDeclaration: ts.ClassDeclaration): ClassMetadata {\n      let result: ClassMetadata = {__symbolic: 'class'};\n\n      function getDecorators(decorators: ts.Decorator[]): MetadataSymbolicExpression[] {\n        if (decorators && decorators.length)\n          return decorators.map(decorator => objFromDecorator(decorator));\n        return undefined;\n      }\n\n      function referenceFrom(node: ts.Node): MetadataSymbolicReferenceExpression|MetadataError|\n          MetadataSymbolicSelectExpression {\n        const result = evaluator.evaluateNode(node);\n        if (isMetadataError(result) || isMetadataSymbolicReferenceExpression(result) ||\n            isMetadataSymbolicSelectExpression(result)) {\n          return result;\n        } else {\n          return errorSym('Symbol reference expected', node);\n        }\n      }\n\n      // Add class decorators\n      if (classDeclaration.decorators) {\n        result.decorators = getDecorators(classDeclaration.decorators);\n      }\n\n      // member decorators\n      let members: MetadataMap = null;\n      function recordMember(name: string, metadata: MemberMetadata) {\n        if (!members) members = {};\n        let data = members.hasOwnProperty(name) ? members[name] : [];\n        data.push(metadata);\n        members[name] = data;\n      }\n\n      // static member\n      let statics: {[name: string]: MetadataValue | FunctionMetadata} = null;\n      function recordStaticMember(name: string, value: MetadataValue | FunctionMetadata) {\n        if (!statics) statics = {};\n        statics[name] = value;\n      }\n\n      for (const member of classDeclaration.members) {\n        let isConstructor = false;\n        switch (member.kind) {\n          case ts.SyntaxKind.Constructor:\n          case ts.SyntaxKind.MethodDeclaration:\n            isConstructor = member.kind === ts.SyntaxKind.Constructor;\n            const method = <ts.MethodDeclaration|ts.ConstructorDeclaration>member;\n            if (method.flags & ts.NodeFlags.Static) {\n              const maybeFunc = maybeGetSimpleFunction(<ts.MethodDeclaration>method);\n              if (maybeFunc) {\n                recordStaticMember(maybeFunc.name, maybeFunc.func);\n              }\n              continue;\n            }\n            const methodDecorators = getDecorators(method.decorators);\n            const parameters = method.parameters;\n            const parameterDecoratorData: (MetadataSymbolicExpression | MetadataError)[][] = [];\n            const parametersData:\n                (MetadataSymbolicReferenceExpression | MetadataError |\n                 MetadataSymbolicSelectExpression | null)[] = [];\n            let hasDecoratorData: boolean = false;\n            let hasParameterData: boolean = false;\n            for (const parameter of parameters) {\n              const parameterData = getDecorators(parameter.decorators);\n              parameterDecoratorData.push(parameterData);\n              hasDecoratorData = hasDecoratorData || !!parameterData;\n              if (isConstructor) {\n                if (parameter.type) {\n                  parametersData.push(referenceFrom(parameter.type));\n                } else {\n                  parametersData.push(null);\n                }\n                hasParameterData = true;\n              }\n            }\n            const data: MethodMetadata = {__symbolic: isConstructor ? 'constructor' : 'method'};\n            const name = isConstructor ? '__ctor__' : evaluator.nameOf(member.name);\n            if (methodDecorators) {\n              data.decorators = methodDecorators;\n            }\n            if (hasDecoratorData) {\n              data.parameterDecorators = parameterDecoratorData;\n            }\n            if (hasParameterData) {\n              (<ConstructorMetadata>data).parameters = parametersData;\n            }\n            if (!isMetadataError(name)) {\n              recordMember(name, data);\n            }\n            break;\n          case ts.SyntaxKind.PropertyDeclaration:\n          case ts.SyntaxKind.GetAccessor:\n          case ts.SyntaxKind.SetAccessor:\n            const property = <ts.PropertyDeclaration>member;\n            if (property.flags & ts.NodeFlags.Static) {\n              const name = evaluator.nameOf(property.name);\n              if (!isMetadataError(name)) {\n                if (property.initializer) {\n                  const value = evaluator.evaluateNode(property.initializer);\n                  recordStaticMember(name, value);\n                } else {\n                  recordStaticMember(name, errorSym('Variable not initialized', property.name));\n                }\n              }\n            }\n            const propertyDecorators = getDecorators(property.decorators);\n            if (propertyDecorators) {\n              const name = evaluator.nameOf(property.name);\n              if (!isMetadataError(name)) {\n                recordMember(name, {__symbolic: 'property', decorators: propertyDecorators});\n              }\n            }\n            break;\n        }\n      }\n      if (members) {\n        result.members = members;\n      }\n      if (statics) {\n        result.statics = statics;\n      }\n\n      return result.decorators || members || statics ? result : undefined;\n    }\n\n    // Predeclare classes\n    ts.forEachChild(sourceFile, node => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ClassDeclaration:\n          const classDeclaration = <ts.ClassDeclaration>node;\n          const className = classDeclaration.name.text;\n          if (node.flags & ts.NodeFlags.Export) {\n            locals.define(className, {__symbolic: 'reference', name: className});\n          } else {\n            locals.define(\n                className, errorSym('Reference to non-exported class', node, {className}));\n          }\n          break;\n      }\n    });\n    ts.forEachChild(sourceFile, node => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ExportDeclaration:\n          // Record export declarations\n          const exportDeclaration = <ts.ExportDeclaration>node;\n          const moduleSpecifier = exportDeclaration.moduleSpecifier;\n          if (moduleSpecifier && moduleSpecifier.kind == ts.SyntaxKind.StringLiteral) {\n            // Ignore exports that don't have string literals as exports.\n            // This is allowed by the syntax but will be flagged as an error by the type checker.\n            const from = (<ts.StringLiteral>moduleSpecifier).text;\n            const moduleExport: ModuleExportMetadata = {from};\n            if (exportDeclaration.exportClause) {\n              moduleExport.export = exportDeclaration.exportClause.elements.map(\n                  element => element.propertyName ?\n                      {name: element.propertyName.text, as: element.name.text} :\n                      element.name.text)\n            }\n            if (!exports) exports = [];\n            exports.push(moduleExport);\n          }\n          break;\n        case ts.SyntaxKind.ClassDeclaration:\n          const classDeclaration = <ts.ClassDeclaration>node;\n          const className = classDeclaration.name.text;\n          if (node.flags & ts.NodeFlags.Export) {\n            if (classDeclaration.decorators) {\n              if (!metadata) metadata = {};\n              metadata[className] = classMetadataOf(classDeclaration);\n            }\n          }\n          // Otherwise don't record metadata for the class.\n          break;\n        case ts.SyntaxKind.FunctionDeclaration:\n          // Record functions that return a single value. Record the parameter\n          // names substitution will be performed by the StaticReflector.\n          if (node.flags & ts.NodeFlags.Export) {\n            const functionDeclaration = <ts.FunctionDeclaration>node;\n            const maybeFunc = maybeGetSimpleFunction(functionDeclaration);\n            if (maybeFunc) {\n              if (!metadata) metadata = {};\n              metadata[maybeFunc.name] = maybeFunc.func;\n            }\n          }\n          // Otherwise don't record the function.\n          break;\n        case ts.SyntaxKind.EnumDeclaration:\n          const enumDeclaration = <ts.EnumDeclaration>node;\n          let enumValueHolder: {[name: string]: MetadataValue} = {};\n          const enumName = enumDeclaration.name.text;\n          let nextDefaultValue: MetadataValue = 0;\n          let writtenMembers = 0;\n          for (const member of enumDeclaration.members) {\n            let enumValue: MetadataValue;\n            if (!member.initializer) {\n              enumValue = nextDefaultValue;\n            } else {\n              enumValue = evaluator.evaluateNode(member.initializer);\n            }\n            let name: string = undefined;\n            if (member.name.kind == ts.SyntaxKind.Identifier) {\n              const identifier = <ts.Identifier>member.name;\n              name = identifier.text;\n              enumValueHolder[name] = enumValue;\n              writtenMembers++;\n            }\n            if (typeof enumValue === 'number') {\n              nextDefaultValue = enumValue + 1;\n            } else if (name) {\n              nextDefaultValue = {\n                __symbolic: 'binary',\n                operator: '+',\n                left: {\n                  __symbolic: 'select',\n                  expression: {__symbolic: 'reference', name: enumName}, name\n                }\n              }\n            } else {\n              nextDefaultValue = errorSym('Unsuppported enum member name', member.name);\n            };\n          }\n          if (writtenMembers) {\n            if (!metadata) metadata = {};\n            metadata[enumName] = enumValueHolder;\n          }\n          break;\n        case ts.SyntaxKind.VariableStatement:\n          const variableStatement = <ts.VariableStatement>node;\n          for (let variableDeclaration of variableStatement.declarationList.declarations) {\n            if (variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n              let nameNode = <ts.Identifier>variableDeclaration.name;\n              let varValue: MetadataValue;\n              if (variableDeclaration.initializer) {\n                varValue = evaluator.evaluateNode(variableDeclaration.initializer);\n              } else {\n                varValue = errorSym('Variable not initialized', nameNode);\n              }\n              let exported = false;\n              if (variableStatement.flags & ts.NodeFlags.Export ||\n                  variableDeclaration.flags & ts.NodeFlags.Export) {\n                if (!metadata) metadata = {};\n                metadata[nameNode.text] = varValue;\n                exported = true;\n              }\n              if (isPrimitive(varValue)) {\n                locals.define(nameNode.text, varValue);\n              } else if (!exported) {\n                locals.define(\n                    nameNode.text,\n                    errorSym('Reference to a local symbol', nameNode, {name: nameNode.text}));\n              }\n            } else {\n              // Destructuring (or binding) declarations are not supported,\n              // var {<identifier>[, <identifer>]+} = <expression>;\n              //   or\n              // var [<identifier>[, <identifier}+] = <expression>;\n              // are not supported.\n              const report = (nameNode: ts.Node) => {\n                switch (nameNode.kind) {\n                  case ts.SyntaxKind.Identifier:\n                    const name = <ts.Identifier>nameNode;\n                    const varValue = errorSym('Destructuring not supported', nameNode);\n                    locals.define(name.text, varValue);\n                    if (node.flags & ts.NodeFlags.Export) {\n                      if (!metadata) metadata = {};\n                      metadata[name.text] = varValue;\n                    }\n                    break;\n                  case ts.SyntaxKind.BindingElement:\n                    const bindingElement = <ts.BindingElement>nameNode;\n                    report(bindingElement.name);\n                    break;\n                  case ts.SyntaxKind.ObjectBindingPattern:\n                  case ts.SyntaxKind.ArrayBindingPattern:\n                    const bindings = <ts.BindingPattern>nameNode;\n                    bindings.elements.forEach(report);\n                    break;\n                }\n              };\n              report(variableDeclaration.name);\n            }\n          }\n          break;\n      }\n    });\n\n    if (metadata || exports) {\n      if (!metadata) metadata = {};\n      const result: ModuleMetadata = {__symbolic: 'module', version: VERSION, metadata};\n      if (exports) result.exports = exports;\n      return result;\n    }\n  }\n}\n\n// Collect parameter names from a function.\nfunction namesOf(parameters: ts.NodeArray<ts.ParameterDeclaration>): string[] {\n  let result: string[] = [];\n\n  function addNamesOf(name: ts.Identifier | ts.BindingPattern) {\n    if (name.kind == ts.SyntaxKind.Identifier) {\n      const identifier = <ts.Identifier>name;\n      result.push(identifier.text);\n    } else {\n      const bindingPattern = <ts.BindingPattern>name;\n      for (let element of bindingPattern.elements) {\n        addNamesOf(element.name);\n      }\n    }\n  }\n\n  for (let parameter of parameters) {\n    addNamesOf(parameter.name);\n  }\n\n  return result;\n}"]}